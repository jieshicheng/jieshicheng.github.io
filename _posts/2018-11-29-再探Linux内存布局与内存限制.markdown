---
layout: post
title: "再探Linux内存布局与内存限制"
date: 2018-11-29 15:20:22 +200
---

上一次接触进程内存布局的时候还是写内核的时候，最近写OJ时需要限制进程内存资源，研究了下Linux下资源限制函数set/getrlimit，本文章便分享下内存布局与内存限制心得。

***前置知识：***

* 操作系统虚拟内存机制
* 操作系统缺中断机制
* Linux可执行文件格式（ELF文件格式）与系统调用
* C语言基础

## 进程内存布局

下图是一个Linux进程的经典内存布局，注意图片最下端为地址0，最上端为地址最高处。下面根据此图依次来说明每个字段的含义，以及这样布置的优点。

![](./post11_1.jpg)

首先需要明确的知识是***虚拟内存机制***。每个进程都逻辑上独占拥有全部的内存，当然是虚拟的。内存分配是分配虚拟内存给进程，当进程真正访问某一虚拟内存地址时，操作系统通过触发缺页中断，在物理内存上分配一段相应的空间再与之建立映射关系，这样进程访问的虚拟内存地址，会被自动转换变成有效物理内存地址，便可以进行数据的存储与访问了。

* ***Kernel space：***操作系统内核地址空间。内存布局中之所以会有内核地址空间，个人有以下两个看法：
	* 操作系统内核代码与数据是已经存储在物理内存上的某一空间，假设它占据了1G内存，物理内存大小为4G，那么对于进程而言，理应显示的可用虚拟内存应该不大于（4 - 1）G，所以它出现在进程内存布局中，占据了一部分虚拟内存，使的进程可见的虚拟内存大小与真实物理内存大小相符。
	* 当然最重要的原因还是因为进程所访问的地址都是虚拟内存地址形式，然而进程需要与内核有交互，因此进程也需要访问内核空间，并且也是通过虚拟内存地址形式访问，所以内核空间需要出现在进程内存布局中。
	
	还有值得注意的是，每个进程的内核虚拟地址空间都是映射到相同的真实物理地址上，因为都是共享同一份物理内存上的内核代码。除此之外还要注意内核虚拟地址空间总是存放在虚拟内存的地址最高处。
	
* ***Stack：***栈空间。在这个区域上有一个Random stack offset（栈随机偏移），这个偏移的主要作用是安全起见。因为内存布局按照严格的规则摆放，因此很容易被恶意访问，通过加入随机偏移，使的每个进程的栈空间起始位置都稍有不同，使的被确定栈空间起始位置具有一定难度，防止被恶意访问。后面的Random brk offset等也是同理。
	* 栈空间大小是一个固定的值，例如4K、8K之类的。但是可以调整其大小，例如在进程中通过改变setrlimit函数的RLIMIT_STACK来调整其大小。栈空间有大小限制，体现在：
		* 1.不能开辟很大的局部对象，例如栈空间为4K，在函数内开辟一个char [1024 * 1024]的数组就会被阻止，因为需要1M空间。
		* 2.嵌套函数调用有层数限制，每当发生一次函数调用时，首先将当前地址压栈，再将函数的参数分别压栈，然后跳转到函数内代码处开始执行，在函数执行结束时，函数的参数分别出栈，再弹出原先压栈的地址，这样就能跳转回函数调用完毕后的代码处了。由此可见，调用一次函数实质上会占用一定的栈空间，当嵌套函数调用层数很大时，就会占据大量栈空间，最终导致栈空间用完。
	* 栈空间有对应的栈指针（esp）。关系是这样的，栈有大小限制，而栈指针表示当前栈用了多少空间。例如，当压栈新的数据时，栈指针便向下增长（esp指针向低地址移动），栈指针到栈空间起始处的内存区域不得大于栈空间大小限制。
	
* ***Heap与Memory Mapping Segment：***堆与内存映射段都属于堆空间，注意下文所说的堆与堆空间并非同一个。堆空间与栈空间的关系很微妙，按理来说都是存数据，为什么还要用两个空间来分别表示呢，从哲学的角度看，数据是有生命周期，大小与顺序的。例如A函数内定义了数据a，B函数内定义了数据b，A函数调用B函数。那么a与b就有了顺序，a的生命周期比b长，b在a之后定义，但a一定在b之后销毁。在这种关系下，完全符合栈的先进后出规则，并且像类似于函数内部的数据（局部数据）而言，每调用一次函数就会产生一个生命周期只在函数调用周期的数据。于是，局部数据就有以下特征：生命周期短且固定（和一个函数的生命周期一致），可能会频繁定义（每次使用函数都会产生），数据之间有严格顺序（a一定比b后销毁），于是用栈来存储这些数据，完美契合。但并不是所有数据都有上面的特征，例如下面这种数据：生命周期不固定（例如打开一个文件，用户决定何时关闭这个文件，那么这个对象数据的生命周期就是不固定的），就不适合放在栈空间，于是用堆空间来保存这些数据。当我们需要在堆空间开辟一块内存来存储这种数据时，称这个过程为动态分配过程。
	* 堆有一个堆指针（break brk），也是按照栈的方式运行的。内存映射段是存在在break brk指针与esp指针之间的一段空间。如前所述，堆空间是要解决生命周期不固定的数据，那为什么会有一个跟栈空间长的很像的堆与堆指针呢。理由是内存分配是一个很昂贵的工作，需要触发缺页中断在虚拟地址与物理地址之间建立映射。而栈空间有大小限制，所以在进程构建之初，便一次性分配了相应的内存，栈大小有4K，那么在进程构建之初，这4K便已经分配好了。然而堆空间的内存，都是用的时候才去分配，如果我们用动态分配去频繁的分配小额内存，那么系统开销会很大（频繁的缺页中断，又释放内存），如果是动态分配一大块内存，那么就比较划算了。例如花一秒钟去分配1G的内存，听上去不亏，但花一秒钟的时间去分配1字节的内存，那么这个一秒钟的开销就很昂贵了。
	* 使用动态分配过程时会根据要分配的内存大小，使用不同的方式。例如在Linux中当动态分配内存大于128K时，会调用mmap函数在esp到break brk之间找一块相应大小的区域作为内存映射段返回给用户，当小于128K时，才会调用brk或者sbrk函数，将break brk向上增长（break brk指针向高地址移动）相应大小，增长出来的区域便作为内存返回给用户。两者的区别是内存映射段销毁时，会释放其映射到的物理内存，而break brk指向的数据被销毁时，不释放其物理内存，只是简单将break brk回撤，其虚拟地址到物理地址的映射依旧存在，这样使的当再需要分配小额内存时，只需要增加break brk的值，由于这段虚拟地址与物理地址的映射还存在，于是不会触发缺页中断。只有在break brk减少足够多，占据物理内存的空闲虚拟内存足够多时，才会真正释放它们。
	* 综合上述两点，堆负责小额内存的管理，内存映射段负责大额内存的管理，如此就能方便的存储数据并且减少动态分配内存时系统的开销了。

* ***Text segment：***代码段。这一块区域是用来存放进程代码的。也就是存放的机器指令。
* ***Data segment：***数据段。又来了一个存放数据的区域，较之于局部数据、动态分配数据，数据段存放的数据自然也有它的特征。全局数据与静态数据是两种很特殊的数据，它们有固定的生命周期：同进程生命周期一样。也就是进程只要存在，那么就需要能访问到这些数据，当然可以把它们存入到栈空间的最底部（最开始入栈的数据，最后被销毁），这样从栈空间存储的数据语义角度上来说没问题，但这样带来了不方便访问的问题，栈空间的访问应遵循从栈顶开始找，栈顶esp的值又是变化的，因此计算起来不方便，直接存储并访问栈底，又不符合栈的规范，因此新开一片空间存储这些数据变的很合理，并且由于可执行文件也是有一个数据段来存储这些数据，因此当操作系统加载可执行文件时，直接复制可执行文件的数据段到内存中的数据段就很方便。
* ***BBS segment：***又。。来一个存放数据的区域。存放的也是全局或者静态数据，只不过相较于数据段，BBS段保存的是全局/静态未初始化数据。前面说了全局或者静态数据在可执行文件中占据一部分区域，也就是说可执行文件的大小会根据程序的全局/静态数据的大小而变化，我们当然期望文件的大小都能小一点，但是已经初始化的数据必须保存在文件中，因为操作系统加载一个程序时，并不会去查看一遍程序本身，它只将可执行文件的不同区域加载到内存中相应位置，因此可执行文件本身必须携带数据的初始值，但是倘若是全局/静态数据并未初始化，换而言之其初始值没有意义，不会被用到，因此可执行文件本身就不需要保存它，只需要记录它便可，例如有100字节的全局字符数组，并未初始化，那么对于可执行文件本身来说，并不需要用真正的100字节来存储这个数据，只需要记录有一个”长度为100的字符数组“即可。前者需要100字节的真实空间，而后者可能只需要几个字符来存储这个信息。所以可执行文件中存储数这种数据使用BBS段存储，减少了文件本身的大小。而操作系统在加载可执行文件时，碰到BBS段，就会解析声明格式并创建真正的空间，然后全部填充为0，作为程序运行时存放全局/静态未初始化数据的区域。


## Linux下限制进程资源

Linux下分别通过系统调用setrlimit与getrlimit设置进程可使用的资源与获取进程可使用的资源。这里主要讨论如何限制进程内存资源。

* ***内存分配：***C语言中通过malloc等函数族来完成内存分配，malloc会根据传入的待分配内存大小分别调用brk()/sbrk()或者mmap()。
* ***内存限制：***可以在命令行下man setrlimit查看具体可以限制的资源种类，涉及到内存相关的有四个：RLIMIT\_AS、RLIMIT\_DATA、RLIMIT\_MEMLOCK、RLIMIT\_STACK。
	* RLIMIT_AS：限制堆空间的最高地址，注意堆空间指的是内存布局中包括堆与内存映射段。对于brk()/sbrk()来说，当提升break brk将会超过这个限制时，返回空指针，并置errno号为12，也就是out of memory，表示内存用尽。对于mmap()来说，它会尝试在break brk到限制地址之间寻找一段区域看是否满足大小要求，若寻找不到，则同样返回空指针并置errno为12。
	* RLIMIT_DATA：限制堆的最高地址，也就是break brk的值不能超过指定限制值。因此哪怕break brk已经接近限制的内存地址值了，但是依旧能分配内存成功，原因可能是用malloc分配大块内存，malloc调用mmap，因此不会影响break brk的值。
	* RLIMIT_MEMLOCK：这个参数限制进程锁定进物理内存的数量。操作系统提供虚拟内存机制，使的可用的内存能大于物理内存，是通过运行时不断将访问量小的内存数据移到外部介质上，从而腾出内存给其他数据使用，当再需要时，再移进来。对于某些程序而言，希望部分数据能常驻物理内存，不被移动来移动去，因此此参数可以完成这项工作。
	* RLIMIT_STACK：用来设置栈空间大小。
* ***注意点：***上述限制只是提供一种非常基础的限制，也很容易被绕开，因此若需要安全并准确的限制进程内存资源，还需要额外的手段。以下几点需要注意：
	* 并非实时检查，以RLIMIT\_AS与RLIMIT\_DATA为例，设立了限制后，只会在调用某些函数时检查限制，例如brk sbrk mmap ...，并且违反限制后只是简单的设置errno值而已，因此并不能说明进程真实的内存使用量。比如可以开辟足够大的全局/静态数据，虽然此时break brk指针的值超过限制，但是你依旧可以正确的访问上述数据，只不过无法malloc新的内存而已。总结来说：使用上述的限制方法，你可以限制进程在运行过程中申请内存时，只有进程内存资源小于限制才可申请，但你无法限制进程在加载时占据的内存量一定小于限制。
	* 违规监控，超过限制的申请内存，只是简单的置errno错误码与返回空指针而已，对于外部进程来说，缺乏监控手段。以fork进程为例，父进程限制子进程内存资源，但当子进程需求内存超过限制时，父进程缺乏直接手段来获取这个信息，除非子进程主动上报或通过一些进程级别的处理函数来完成这个功能。
	* 限制数值太僵硬，限制的都是死的虚拟地址，不同的进程因为代码与全局数据的原因，break brk最开始的值都是不同的，因此统一的值对不同进程而言，其可用的内存空间数是不同的，倘若要针对所有的进程具有一样的内存使用量，需要先获取end_code指针（代码段结尾），再用可用内存数相加，便可以限制进程数据大小了（代码段结尾是数据段，BBS段，堆空间，除开局部数据，其他数据都在这里，而局部数据一般不纳入内存资源限制的考虑空间，因为栈空间本身有大小限制）。
