## \#if __cplusplus

__cplusplus是一个针对cpp代码定义的宏，常用的地方

#### 1.使编译出来的代码更通用

```
#ifdef __cplusplus
extern "C" {
#endif

//some code ...

#ifdef __cplusplus
}
#endif
```

这样可以使的c++文件与c文件混合使用。我们知道c++支持重载，其实现原理就是在针对每个函数的名字进行一套额外的变换，例如函数

```
int a(int a, int b);
int a(int a);
```

针对这样的重载函数，编译器会生成不同的函数名来区分这两个函数，结合返回类型与参数类型与数量

```
int int_a_int_int(int a, int b);
int int_a_int(int a);
```

然而c语言中没有这么复杂，可能只是简单的加一些下划线特殊字符等，而不会跟函数的声明方式挂钩，因此当混合使用c与c++目标文件时，两个语言对于函数名的处理方式不同，因此当c想要调用c++的一个函数时，可能会按照c的方式对函数名进行改变，然后去查找并调用导致查找不到调用失败。通过使用上述代码，可以使的编译出来的代码能够被c与c++混合使用。

#### 2.检查编译器支持的标准

```
#if __cplusplus >= 201103L

//some code

#endif
```

__cplusplus的具体数值表示了编译器支持的标准，其中201103L表示2011年03月提出的标准，也就是c++11，还有199711L，如上所述，也是一个标准。但由于历史的原因，其数值可能在少数编译器上（例如古老的cfront等）存在问题。

通过使用上述代码，可以检查编译器支持的标准版本，针对标准的不同使用不同的代码。

## #pragma

#### 1.在编译期间输出指定信息

```
#ifdef _MACRO_ONE
#pragma message("_MACRO_ONE is defineded")
#endif
```

通过搭配ifdef宏，可以在编译期间将预定义的宏输出在编译信息中，方便检查。

#### 2.设置字节对齐数

```
#pragma pack(push, 8)

...some code

#pragma pack(pop)
```

设置按照多少字节对齐，在自定义的协议中经常使用，使的c/s两端生成数据字节一致，方便协议解析。