---
layout: post
title: "DP-动态规划心得"
data: 2016-12-10 12:33:12 +200
---

学习DP问题也有近一个月了，从初次接触01背包问题，到花了几天思考，最后恍然大悟，再陆续到后面的LCS，完全背包，等一系列变种的DP问题，越了解心中的佩服之情越盛，感叹逻辑之美以及，真的只能承认，智商的差距，有时真的遥不可及。

步入正题，选了一道最简单的DP问题来练手，尽管非常简单，但没想到真正AC下来，还是出乎意料的花了很久。

## 例题

**问题描述：**

妈妈给小B买了N块糖！但是她不允许小B直接吃掉。

假设当前有M块糖，小B每次可以拿P块糖，其中P是M的一个不大于根号下M的质因数。这时，妈妈就会在小B拿了P块糖以后再从糖堆里拿走P块糖。然后小B就可以接着拿糖。

现在小B希望知道最多可以拿多少糖。

**输入格式：**

一个整数N

**输出格式：**

一个整数，小B最多可以拿多少糖

**样例输入：**

15

**样例输出：**

6

**数据规模和约定：**
N <= 100000

## 题解

**初次做题心得：**

1.审题仔细，等到完全理解清楚题意，再去思考

2.思路理清楚，逻辑弄明白，再动手写代码

3.写完以后尽量做一些简单的优化一下（能更深层次的优化更好）

**解题思路：**

这道题关键在于数字P，首先理解数字P，它有三个条件，其一是质数，其二是M的一个因数，其三要小于等于根号下M。

接下来看问题，问的是：**若当前总共有N颗糖，希望知道最多可以拿多少糖**。

我们用f(N)来表示对这个问题的解。

分析这道题重点如下：

**若当前总共有N颗糖可供选择，假设可以拿的数量为p1，p2，p3（p1 < p2 < p3）。是否总是选最大的那个值（例如选p3）为正确的呢？不是，当且仅当f(N - p3)  + p3 > f(N - p2) + p2 且 f(N - p3) + p3 > f(N - p1) + p1成立时，选p3才是正确的，而我们无法证明上述公式在先决条件（p1 < p2 < p3）下百分百成立，因此对于这道题目也就无法使用贪心算法解决**

**若对于当前f(N)，我们知道可拿的数量集合为{p1, p2, p3 ..., pn}，那么我们就需要依次计算相应的f(N - pi) + pi的值，选取计算结果中最大的那一个，这是一个递归的过程，也是一个暴力计算的过程**

通俗的讲，假设有N = 15，我现在已经知道了f(1), f(2), f(3) ..., f(14)的答案，N = 15时，它的质因数为1或者3.也就是说，我如果拿1颗，那么还剩15 - 1 * 2 = 13颗，而我已经知道了f(13)，那么N = 15时，我能拿到的糖果就是f(13)加上我能拿的1颗。同理，还要考虑质因数为3的情况，两种情况中那个情况最优，则答案就是那个。

到目前为止，我们所做的都是朴素的暴力计算方式，算法性能是非常低的，由于是递归，因此计算量展开来看是树形结构，并且分支的数量取决于质因数的数量，最大深度则为总糖果的数量（因为1是共有的质因数，则必然会经历计算f(N - 1), f(N - 2) ...），由此我们也可以看出，相当多的重复计算是性能低的主要原因，例如f(4)，可能来自于f(6 - 2)或者f(11 - 7)，而每次都需要重新计算f(4)。因此我们将计算过的结果保存下来，因为决定我们结果的数据是一维的，所以我们可以用一个数组轻松保存。

所以我们可以得出递推式：

**dp[i] = dp[i - 2 * prime] + prime**

其中，prime是小于等于根号i的质因数，i代表当前的糖果数量，dp[i]的值为当糖果数量为i时我能拿的最多的糖果。

当然，我们这个递推式还不完整，还漏了一点。就是会有多个质因数可以供选择，我们必须对于每个质因数都计算一次，然后选其中最大的情况，所以，完善后的递推式为

**dp[i] = max(dp[i], dp[i - 2 * prime] + prime)**

## 代码

```
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

int main()
{
    vector<int> prime;
   //存放小于等于根号下 number 的所有质数
    int number;            //等待输入的总糖果数量
    bool flag;            //状态。判断一个数字是不是质数

    cin >> number;
    vector<int> dp(number + 1, 0);   //dp向量。记录当糖果数量为i时能拿的糖果

    //求质数，并将所有质数保存到prime中
    int sqt1 = sqrt(number);
    for(int i = 2; i <= sqt1; ++i)
    {
        int sqt2 = sqrt(i);
        flag = true;
        for(int j = 2; j <= sqt2; ++j)
        {
            if(i % j == 0)
                flag = false;
        }
        if(flag == true)
            prime.push_back(i);
    }
     
    //处理dp向量
    for(int i = 1; i <= number; ++i)    //i代表dp的下标，代表糖果的数量
    {
        int sqt2 = sqrt(i);
        int _size = prime.size();
        for(int j = 0; j != _size; ++j)      //遍历整个质数的数组
        {
            if(prime[j] <= sqt2 && i % prime[j] == 0)  //如果这个质数小于等于根号下当前糖果的数量 且 是它的因数的话
            {
                dp[i] = max(dp[i],dp[i - 2 * prime[j]] + prime[j]);  //求最优解
            }
        }
    }

    cout << dp[number];
    return 0;
}
```
