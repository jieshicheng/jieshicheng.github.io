---
layout: post
title: "算法竞赛中数学思想与方法的使用"
date: 2018-05-15 2:2:2 +200
---

## 一.辗转相除法——除法表达式
> 题目：给定连除表达式x1 / x2 / x3 / x4 / x5 / x6 / x7 ... / xn，xi都是正整数。在其中随意添加括号，求解是否存在一种形式能使得最后计算结果为正整数。

首先设集合V = {x1, x2, x3, x4, x5, x6, ..., xn}，问题可以逐渐转换变简单，通过以下几个步骤，就可以将这个问题简单化：

**1.思路1:A / B，其中A为集合V中一部分数据相乘的结果。B为集合（V - A）集合的数据相乘的结果。那么问题就变成判断A / B是否为整数。**

**2.思路2：为了使得A / B为整数，可以转换目标为判断是否A的全部约数包含B的全部约数。若全部包含则结果过整数，反之不为整数。**

因此我们只需要查看最优情况下A / B是否为整数就行了，如果最优情况下都不为整数，那么其他情况下必然也不存在解。

那么最优情况下是什么呢？就是B的约数集合最小，A的约数集合最大的时候，这时候A的约数集合全包含B的约数集合的概率就最大，就是最优情况。

**3.思路3:通过观察可知：无论如何添加括号，x2必然会出现在B集合中，而其他数据则可以根据添加的括号形式的不同而出现在A或B集合中。**

那么根据我们上述讨论的最优化，既然B集合中固定出现x2，其他的数据可以出现在A或B中，那么使得B集合中只包含x2，A集合中包含所有其他数据时，便是我们讨论的最优情况。

如下形式：

（x1 * x3 * x4 * x5 ... * xn) / x2

那么怎样添加括号出现上述情况呢？如下所示：

x1 / (x2 / x3 / x4 / x5 / x6 ... / xn)

**到了这一步，我们将原本的问题转换成了求（x1 * x3 * x4 * x5 ... * xn)中的约数是否包含x2的全部约数。**

貌似到了这一步已经很简单了，但其实我们还可以更简单一步，求他们两者的全部约数可以换个角度去思考，我们不用直接算x1 * x3 * x4 * x5 ... * xn的值，然后再求它的约数，这么多相乘容易溢出。

转换思路4:我们可以用约分的思想去把其中每个xi与x2的最大公约数都约去，例如(8 * 4) / 16就可以先用8与16的最大公约数约去为将公式简化为(1 * 4) / 2。

又因为最后只需要求解是否为整数，则分子约去后的值不用管，只需要去更新分母的值x2 = x2 / gcd（xi, x2）即可。

最后只要x2的值为1的时候解就是可为整数，当算完以后都不为1则解为不行。

上述解法的时间复杂度很大程度取决于如何求gcd，利用辗转相除法可以大大提升我们算法的执行效率。

[代码地址](https://github.com/jieshicheng/OI_practive/tree/master/155_mathTraining1)


## 二.Eratosthenes素数筛法——无平方因子的数

> 题目：给定区间[n, m]。求其中有多少个无平方因子数。无平方因子数p的定义为当且仅当不存在任何k > 1，p % （k * k） == 0

首先在暴力的角度去思考，就是遍历[n, m]中每个元素xi，然后判断xi是否为无平方因子数，判断的方法也是暴力遍历1 -> sqrt（xi)。虽然很暴力但是给我们提供了一个优化的思路，首先我们可以得知，素数必然都是无平方因子数，其次在非素数中存在一部分数是无平方因子数，比如15。

**1.思路1:也就是说我们需要找出[n, m]区间内的所有无平方因子数也就是需要找出[n, m]区间内的素数加上一部分有着共同未知特性的非素数。素数好找，那么有着共同未知特性的非素数怎么找？首先我们需要找出这个未知特性是什么。**

这里便需要引入一个公式，算数基本定理：任何一个大于1的自然数N，如果N不是素数，那么N必定可以唯一分解成有限个素数的乘积。如下形式：

**N = P1^a1 * P2^a2 * p3^a3 * .... PN^aN。**

注意定义中的措辞：必定可以、唯一。换而言之就是存在性与唯一性。那么根据这个公式我们可以看出，首先N满足我们要研究的对象——非素数，其次每一个N都可以唯一的被一堆素数表示，那么我们想要寻找的非素数的共同未知特性必然就存在于这个等式的右边中。

以15这个非素数举例，15 = 3^1 * 5^1，注意这个等式是必然存在且唯一的（换而言之就是15只能写成这种表示法），回到题目最初的要求，15之所以是无平方因子数，在这个式子中我们可以更直观的明白，因为15的乘积表示形式中根本找不到二次的形式，并且连乘的每个数Pi都是素数，也就是不存在这个Pi为另外某个数的平方。这不仅完美的诠释了题目的要求，也解答了我们所寻找的共同未知特性。

现在，我们需要找出[n, m]中的非素数且为无平方因子数很简单，只需要用小于√m的所有素数的一次指数形式去计算N，只要N满足 n <= N <= m。求出所有的N，再加上区间[n, m]的素数，便是最终的解。

*2.转换思路2:尽管到了这一步已经做完这道题目了，但依旧存在可以优化的地方，在于区间[n, m]的所有数据可以分为3类。1.素数 2.非素数为无平方因子数 3.非素数不为无平方因子数。反观我们上述的解法，我们是求种类1和2的数量，然而种类2的数量其实不好求，要枚举众多情况，因此我们可以反行之，求种类3的数量，再用整体减去种类3的数量即使正解。而种类3的求法非常简单，在我们上述算数基本定理公式中的右边存在一个Pi指数大于等于2的形式，那么这个数便不是无平方因子数（为什么？留待自行思考。）因此我们只需要用小于√m的所有质数Pi，算出Pi^2 * k(k为倍数 k > 1即可)，然后这个 n <= Pi^2 * k <= m便是区间内的种类3。**

在我们算法过程中，复杂度的大小点在于求√m的所有素数，通过使用Eratosthenes素数筛法可以快速的求出想要的素数区间，大大提升我们的算法效率。

[代码地址](https://link.zhihu.com/?target=https%3A//github.com/jieshicheng/OI_practive/tree/master/156_mathTraining2)


## 三.总结

尽管这两道题目主要是为了说明数学方式在题目中的应用，但实际这两道题目个人认为更重要的是思路的转换，通过利用数学理论的支持，不断的转换解决问题的角度，最终通过把一个复杂问题用逻辑证明的方法改成一个简单可求的问题，解决这个小问题就可以反证复杂问题的解。
