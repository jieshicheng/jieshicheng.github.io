---
layout: post
title: "一只脚迈进DP的海洋"
date: 2017-03-12 01:12:56 +200
---

（PS：本文适合初次接触动态规划以及AC题目20道以内的初学者）

前文：DP是一个适用领域非常浩瀚的算法思想，同时，也非常有意思。说它简单，它的核心思想可以以一言而概之。说它复杂，因为你总能在其中思考更多，学会更多。借MIT算法导论课中教授的一言，“每年我对于动态规划都有一个全新的理解”。由此可见DP的浩瀚以及深度。

下文，我将就个人对于DP的理解借助几个简单的例子展示出来，若有不当之处，请指正。

我第一次接触DP时，例子是01背包问题，但是在我看来，这个例子作为第一个入门的题目是不太适合的，一是不够简单，二是对于大部分初学者来说不够熟悉，所以经过抉择后我选择用“斐波那契数列”作为第一个例子，01背包问题作为第二个。

## 斐波那契数列

相信大部分人对于斐波那契数列应该是再熟悉不过了，我们先来看一个朴素的求斐波那契的算法

```
int fib(int x)
{
    if(x == 0)
       return 0;
    else if(x == 1)
       return 1;
    else
       return (fib(x - 1) + fib(x - 2));
}
```

这个算法的时间复杂度是指数级别的，非常差劲，我们有许多办法可以优化斐波那契数列，用线性迭代算法可以约束到线性时间以内，用矩阵加反复幂运算可以优化到对数级别，不过现在，我们抛开所有已知的优化方法，我们就这个指数级别的算法来看，一个影响这个算法复杂度的至关重要的因素是**重复计算**

![picture 1](/assets/post_picture/post3.1.jpg)

我们将递归展开来看，对于求斐波那契第四个数字，它计算第二个数字两次，第一个数字两次，而这些重复计算正是导致这个朴素算法的时间复杂度居高不下的原因，如果是要优化这个算法，理所当然的，我们第一直觉就是去除重复的计算，因而我们选用一个数组，来将计算过的值保存进去，当再次面临计算时，我们先查看数组里面对应的值是否存在，存在的话，直接取过来用便可了，不存在话，再进行计算。

优化后的递归算法如下所示:

```
int array[x];     //全部初始化为-1
array[0] = 0;      //初始化边界条件
array[1] = 1;
int fib(int x)
{
    if(array[x] != -1)
        return array[x];
    else
        return array[x] = (fib(x - 1) + fib(x - 2));
}
```

我们来分析分析这个算法，展开递归来看，依旧是树形递归，只不过当前这个树的形状有点极端，大概是这样的

![picture 2](/assets/post_picture/post3.2.jpg)

（图中虚线部分为无需计算的值）

我们发现这是一个极端的左斜树，倘若我们把虚线部分也都去掉，因为那些值无需计算，直接调用的数组，就会发现这个递归展开，已经不能说做是一颗树了，而是一条斜线，自然而然的它的时间复杂度也就从指数级降为线性了，我们称在搜索的过程中将重复计算的数值保存起来的操作叫做记忆化搜索。

然后我们再就这个线性递归优化，将它优化成迭代的形式，以减少函数栈的调用消耗，就变成了大家最为熟悉的计算斐波那契数列的方式了

```
int fib(int x)
{
    int suf = 1;
    int pre = 0;
    int temp;
    for(int i = 2 ; i <= i ; ++i)
    {
        temp = pre;
        pre = suf; 
        suf += temp;
    }
}
```

第一个例子讲完了，倘若你为发现其中的蹊跷之处，必然会觉得简单，但其实不然。

我们目前的操作极其简单，将重复计算保存下来，我们便使得一个算法的复杂度下降了一个数量级，但是什么原理在其背后支撑着呢？首先，我们对于这一类重复计算的问题展开思考——**为什么会出现重复计算？**

让我将这句话说得再详细一点（假设我们在计算x）——为什么计算第x个斐波那契数的时候要用到第x - 1个？当然，你会说这是数学家给出的公式，好的，那么我们将思维抽象出斐波那契数列，我们思考这一类问题，斐波那契数列的问题模板可以抽象成：求 XX1 在 XX2 中的最优解。因为我们可以将斐波那契数列的问题说成：求第四个数字在斐波那契数列中的值（最优解）。

现在，终于引出最优解这个词了，让我们将目光聚焦在一类问题上，这一类问题是给定某个范围，要我们求其中的最优解，那么，我们就可以指出动态规划的最简单的一个定义：

全局最优解必定包含着局部最优解。

这个不难证明，我们用反证法，倘若全局最优解 x = { x1, x2, x3 }，其中x1,x2是他们各自局部的最优解，而x3不是，x3′才是局部最优解，那么我们可以证明集合 x′ = { x1, x2, x3′ } 形成的全局才是最优解，而前者 x 不是。

这个才是我们计算x的斐波那契数却需要计算x - 1的真正的原因。

讲完了基本的概念，我们可以有以下总结：

通过记忆化搜索来减少计算量

全局最优解必然包含着局部最优解

现在，我们回归正儿八经的DP题目，也是非常著名的DP题——01背包问题

## 01背包问题：

有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？

这道题与上道题非常类似，我也将遵循循序渐进的方法，一步步将它优化到我们希望的复杂度。

首先面对这种题目，直观的做法是穷竭搜索。将所有装物品的方式都考虑一遍，然后取其中最大的价值就行了，代码如下

```
int value[] = {6,3,5,4,6};  //5个物品，每个物品的价值
int weight[] = {2,2,6,5,4};  //每个物品的重量
int answer = 0;          //最后答案
void dp(int wet , int val , int i) //wet为当前背包剩余的重量，val为背包的价值，i为当前遍历到第几个物品
{
    if( i == 5 )   //如果遍历完5个物品了，记录最高的val。
    {
        answer = val > answer ? val : answer;
        return ;
    }
    if(wet >= weight[i])      //如果当前剩余背包的重量足够装下第i个
    {
        dp(wet - weight[i] , val + value[i] , i + 1);  // 装下
        dp(wet , val , i + 1);    //不装
    }
    else                //当前重量不够，装不下第i个
        dp(wet , val , i + 1);    //不装
}
```

这个递归算法展开的话是一个非常庞大的完全二叉树，极度平衡，指数级算法。

![picture 5](/assets/post_picture/post3.3.jpg)

结点中的数字代表当前背包剩余重量，每一个结点左边走代表装下当前的物品，右边走代表不装下。

相信眼尖的一眼就能看见其中的重复计算处，理所当然的我们选择用数组来保存其中的重复计算，只不过这道题不像上题中的那么直观了，在这里，因为一个解与2个数据相关联，所以我们需要用二维数组来保存重复计算的数据。

并且，题目问的是求能够获得的最大价值在背包容量为10的最优解，显而易见的，如果当前背包容量为10的时候拿到的最大价值，那么我们可以知道它一定建立在背包容量为9,8,7……的时候能拿到的最大价值的基础上。所以这是一个典型的求全局最优解的问题

我们令二维数组为dp[i][j]；其中i为{0,1,2,3,4,5}，代表5个物品。j为当前背包的容量（1到10）**所以dp[i][j] 的含义为拥有背包重量为j，可以拿前i个物品时能拿到的的最大价值**。现在让我们进入填数字游戏，游戏背景是这张表格

![picture 6](/assets/post_picture/post3.4.jpg)

其中dp[5][10]，也就是最右下角的小格子便是我们要求的答案——前5个物品中选重量不超过10的最大价值。

我们再来观察这个游戏中有没有什么巧妙的方法可以快速填完这张表。

我们就答案入手，假若我们需要求dp[5][10]，并且这整张表格除了要求的这一个其他的格子我们都填完了，那么我们知道在前5个物品中挑选重量不超过10的最大价值等于下面两种情况中数值更大的那一个

**1.在前四个物品中挑选重量不超过10的最大价值**

**2.在前4个物品中挑选重量不超过( 10 减去 weight[5] )的最大价值加上 value[5]**

我们先说第一种，在前四个物品中挑选重量不超过10的最大价值，也就是说我已经装满了背包装不下了第五个了的时候我能拿到的最大价值。

第二种情况则是 ，在前四个物品中我挑选了重量总计不超过6（10减去第五个物品的重量4，等于6）的最大价值，现在面对第五种，正好背包可以放下，那么将第五个放进去，先前总价值再加上第五个物品的价值便是最大价值。

也就是我们得到递推式

**dp[i][j] = max( dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i] )**

这样便能够顺利的填完整张表，最后，答案自然也就是呼之欲出了。

有了这个递推式后，我们可以用迭代或者递归，在O（n * m）的时间复杂度内遍历完这张表，最后再输出答案即可。

对于初学者，建议补充完整张表格，并且将递归代码改用迭代形式完成，做完这些，才是实打实的掌握了这道题。

最后留两个思考题：

**1.如何用一维数组代替二维数组？（解析可到网上查 “滚动数组”）**

**2.01背包有个升级版名为完全背包，难度更加大，递推式更复杂。建议去尝试推导**


## 总结：

经历了两个例子的理解，现在说一下DP的核心想法。

因为存在全局最优解和局部最优解的关系，所以我们可以将求全局最优解分解成求解局部的最优解，然后再递推出全局最优解，所以重中之重便是递推关系式

最后再强调几个注意的地方:

**1.记忆化搜索并不代表DP，只是DP很多特性需要用到记忆化搜索，除此之外，DP还有许多巧妙的技巧也是非常有意思的，有兴趣的可以深入。**

**2.在面对问题的时候，如果能一步写出递推式是最好的，倘若递推式不是很明了的话，可以从朴素的角度去思考然后一步步往上优化，自然而然就能找到递推式了。**

**3.任何思想都是要经过足够的思考才能碰撞出自己的想法，所以面对动态规划，多做题多思考。这样才能做到真正的高屋建瓴。**
